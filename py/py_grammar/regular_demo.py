import re

# 匹配单个字符
# .匹配任意字符（除了\n）
# [] 匹配罗列出来的任意一位 （可以罗列也可以 0-x）
# \d 匹配数字
# \D匹配非数字
# \s匹配空白字符
# \S匹配非空白字符
# \w匹配普通字符（字母、数字、下划线、汉字）
# \W匹配特殊字符

# 匹配多个字符
# * 匹配前面的字符0-无限次（可有可无）
# + 前面的字符至少出现一次
# ？匹配前一个字符要么出现一次，要么出现0次
# {m} 前一个字符出现m次
# {m, n} 前一个字符最少m次 最多n次

# ^匹配字符串的开头，[^sasd] 除了罗列的sasd外，所有字符都匹配
# $匹配字符串的结尾

# 匹配分组
#  | 匹配左右的任意表达式（左右两边的正则表达式只要匹配一个即可）
# （ab） 将括号中的字符作为一个分组 .group 方法返回的默认是分组0， 小括号从左到右分组从1开始
#  \num 引用分组num匹配到的数据，<html>123123</html> "<[a-zA-Z1-6]+>.*</\\1>"
#  （？p<name>） 分组起别名
#  （？p=name） 引用别名为name分组匹配到的字符串


if __name__ == '__main__':
	# match_obj = re.match("[a-zA-Z0-9_]{4,20}@[a-zA-Z0-9_]{2,10}\.com", "dagedan@gmail.com")
	match_obj = re.match("^1[3-9]\d{9}$", "13888898789")
	if match_obj:
		result = match_obj.group()
		print(result)
	else:
		print('匹配失败')
